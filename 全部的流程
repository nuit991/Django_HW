1.安裝python，打勾第3方那個框框

-------------
2.安裝VS Code，VS Code裡面下載python

Daphne 是用于运行 Django Channels 项目的 ASGI 服务器。它支持 WebSocket、HTTP2、长轮询等协议，并用于处理异步请求。
使用 Daphne 来运行 Django 项目，尤其是涉及 WebSocket 或实时通信时，是常见的选择。
這邊要處理Daphne + WebSocket

-------------
3.先處理Daphne
cmd 下 
pip install daphne 
pip install daphne channels

回到Django那堆資料夾裡面，有Project_1 跟 myapp，選擇Project_1這個

-------------
A.新增Porject_1/asgi.py
輸入

# myproject/asgi.py
import os
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from myapp import routing

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'Project_1.settings')

application = ProtocolTypeRouter({
    #處理http的東西
    "http": get_asgi_application(),
    #處理websocket的東西
    "websocket": AuthMiddlewareStack(
        URLRouter(
            #導入myapp/routing.py 文件中定义的 WebSocket URL
            routing.websocket_urlpatterns
        )
    ),
})

-------------
B.處理Porject_1/urls.py
#这是导入 Django 自带的管理模块，用于启用 Django 管理后台。
from django.contrib import admin

#path：Django 中的 URL 路由方法，用于将某个特定 URL 路径与一个视图函数或包含文件关联起来。
#include：允许你将其他 URL 配置文件包含进来，便于管理不同应用的 URL 路由，尤其当项目变大时。
from django.urls import path, include

urlpatterns = [
    #当用户访问 http://yourdomain.com/admin/ 时，Django 会将请求交给 admin.site.urls 处理。
    #admin.site.urls 是 Django 内置的管理后台的 URL 配置，通常用来访问 Django 管理后台界面。
    path('admin/', admin.site.urls),
    #这里的 path('', ...) 表示当用户访问网站根路径（如 http://yourdomain.com/）时，Django 将请求交给 myapp.urls 处理。
    #include('myapp.urls') 会将请求路由到 myapp 应用中的 urls.py 文件中去寻找更多的 URL 路由定义。这种方式使得你可以在不同的 Django 应用中各自管理自己的 URL 路由，保持项目的可维护性。
    path('', include('myapp.urls')),
]

'''
網頁上輸入127.0.0.1，會先到這邊詢問path('', include('myapp.urls'))，然後這邊再去myapp/urls.py裡面詢問
'''

-------------
C.更改Porject_1/settings.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # 你的应用
    'myapp', #這個是增加的
    # 添加 channels 以支持 ASGI
    'channels', #這個是增加的 
]

#處理異部
ASGI_APPLICATION = 'Project_1.asgi.application' #添加 ASGI_APPLICATION 设置，这会告诉Django使用 asgi.py 文件作为ASGI入口点
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels.layers.InMemoryChannelLayer"
    }
}

-------------
D.更改celery.py


#absolute_import: 确保导入模块时使用绝对导入而不是相对导入。这有助于避免模块导入冲突，特别是在有复杂包结构的项目中。
#unicode_literals: 在 Python 2.x 中，使得所有字符串文字被解释为 Unicode 字符串（在 Python 3.x 中默认行为）。
from __future__ import absolute_import, unicode_literals
import os
#从 Celery 包中导入 Celery 类。Celery 是一个异步任务队列/作业队列系统，允许你在后台运行耗时的任务或定时任务。
from celery import Celery

# 这行代码的目的是告诉 Django 应用程序应该加载 Project_1 项目的 settings.py 配置文件。它是 Django 启动时的关键步骤，确保项目运行时能加载正确的设置。
# 這一段告诉 Django 去加载这些配置，使得 Django 知道如何启动项目、连接数据库、加载应用、处理静态文件等。
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'Project_1.settings')

#创建一个 Celery 实例。'Project_1' 是这个 Celery 应用的名字。通常，Celery 应用的名称与项目名称一致，以便于管理和调试。
app = Celery('Project_1')

# 从 Django 设置中加载 Celery 配置。namespace='CELERY' 表示 Celery 配置项应以 CELERY_ 前缀作为前缀。
# 例如，CELERY_BROKER_URL 会从 Django 的设置中读取。这样，你可以在 Django 的 settings.py 中配置 Celery 的相关参数。
app.config_from_object('django.conf:settings', namespace='CELERY')

# Celery 会遍历所有已注册的 Django 应用，并自动发现每个应用中的任务模块（通常是 tasks.py 文件）
# 这样，你可以将任务定义在不同的 Django 应用中，Celery 会自动加载这些任务。
app.autodiscover_tasks()


'''
pip install celery
這東西用在__init__.py裡面


这段代码完成了以下任务：
Celery 是一个用于处理异步任务的任务队列库。它允许你将任务分配给后台工作进程，从而使这些任务在主程序的前台流程中异步执行。
这种方式特别适用于需要长时间处理或频繁执行的任务，如发送电子邮件、处理图像或执行复杂计算等。

设置 Django 的环境配置，使 Celery 能够访问 Django 的设置。
创建一个 Celery 实例，配置其使用 Django 的设置来配置 Celery。
自动发现和注册所有应用中的任务，使 Celery 可以处理这些任务。

'''

-------------
E.
