<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MOMO - 搜索結果</title>
    <style>
        /* 页面样式定义 */
        .product-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            gap: 20px; /* 设置列与列之间的间距 */
        }
        .product-item {
            width: 19%; /* 每行显示5个产品 */
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ddd; /* 添加边框以区分产品 */
            border-radius: 5px; /* 轻微的圆角效果 */
            background-color: #f9f9f9; /* 背景颜色 */
            text-align: center; /* 文本居中 */
        }
        .product-item img {
            max-width: 100%;
            height: auto;
            border-radius: 5px; /* 图片圆角 */
        }
        .product-item h3 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            color: #333;
            font-size: 1em;
            margin: 5px 0;
        }
        .product-item a {
            display: inline-block;
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            text-decoration: none;
            border-radius: 5px;
        }
        .product-item a:hover {
            background-color: #0056b3;
        }
        #total-items {
            margin-top: 20px;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <h1>MOMO - 搜索結果</h1>
    <div id="product-container" class="product-row"></div>
    <div id="total-items">共 0 件商品</div>

    <script>
        //前端輸入的商品名稱跟頁數會丟過來
        const productName = "{{ product_name }}";
        const maxPages = "{{ max_pages }}";


        // 创建 WebSocket 连接  
        //建立了前端与后端之间的 WebSocket 连接，允许双向数据通信。此时连接已建立，但数据尚未传输。
        const socket = new WebSocket('ws://' + window.location.host.replace(':8000', ':9000') + '/ws/momo/');

        //当 WebSocket 连接成功打开时，onopen 事件触发，前端通过 socket.send() 方法向后端发送一个初始消息，告知后端开始搜索指定的商品。
        socket.onopen = function(event) {  
            //这行代码在控制台输出一个消息，显示 WebSocket 连接已成功打开，并附带 event 对象的信息。这有助于在调试时了解连接的状态和相关信息。  
            console.log('WebSocket connection opened:', event);

            // socket.send() 是 WebSocket 提供的一个方法，用于向服务器发送数据。
            //JSON.stringify({...}) 将一个 JavaScript 对象转换为 JSON 格式的字符串，以便通过 WebSocket 传输。
            socket.send(JSON.stringify({
                //表示发送的命令是 "start"，告诉服务器要开始执行某个操作（如开始搜索）。
                'command': 'start',
                //product_name: productName：将 productName 的值（通常是用户在前端输入的商品名称）发送给服务器，告诉服务器要搜索哪个商品。
                'product_name': productName, 
                //max_pages: maxPages：将 maxPages 的值（用户指定的最大搜索页数）发送给服务器，告诉服务器搜索的最大页数限制。
                'max_pages': maxPages 
            }));
        };

        // 监听 WebSocket 消息    
        // 跟const socket = new WebSocket('ws://' + window.location.host.replace(':8000', ':9000') + '/ws/momo/');拿資料
        // 服务器端在处理完请求后，会通过这个 WebSocket 连接发送数据到前端。每当服务器发送数据时，socket.onmessage 事件被触发，event.data 包含了服务器发送的内容。
        socket.onmessage = function(event) { //通过访问 event.data，你可以获取并处理服务器发送的消息，通常会根据应用需求解析并处理这些数据。
            //这行代码在控制台输出一条消息，内容是收到的 WebSocket 消息。这是用于调试的，便于开发者了解收到的数据内容。
            console.log('WebSocket message received:', event.data);
            //功能：event.data 是服务器发送的消息数据，通常是字符串形式。使用 JSON.parse() 将这个字符串转换为 JavaScript 对象，便于后续处理。
            const data = JSON.parse(event.data);
            //功能：查找页面上 ID 为 product-container 的 HTML 元素，这个元素是一个容器，用来存放接下来创建的产品项。
            const productContainer = document.getElementById('product-container');

            // 功能：创建一个新的 div 元素，并设置其类名为 product-item。这个 div 用来展示单个产品的信息。
            const productItem = document.createElement('div');
            productItem.className = 'product-item';
            
            //功能：使用模板字符串将产品名称 (data.prd_name)、价格 (data.price)、图片 (data.img_url) 以及链接 (data.product_url) 添加到 productItem 中
            //onerror="this.onerror=null;this.src='default.jpg';" 用于处理图片加载失败的情况，设置一个默认图片。
            productItem.innerHTML = `
                <h3>${data.prd_name}</h3>
                <p>價格：${data.price}</p>
                <img src="${data.img_url}" alt="Product Image" width="200" height="200" onerror="this.onerror=null;this.src='default.jpg';">
                <a href="${data.product_url}" target="_blank">查看商品</a>
            `;

            // 功能：将创建好的 productItem 元素添加到之前找到的 product-container 容器中，显示在网页上
            productContainer.appendChild(productItem);

            // document.getElementById('total-items')：找到显示商品总数的元素。
            const totalItemsElement = document.getElementById('total-items');
            //parseInt(totalItemsElement.textContent.match(/\d+/)) || 0：提取当前显示的商品数量，如果没有数字则返回 0。
            ///\d+/ 是一个正则表达式
            //\d 表示任意一个数字字符（0-9）
            //+ 表示前面的模式（即数字字符）可以匹配一次或多次。
            //match() 是一个 JavaScript 字符串方法，它接受一个正则表达式作为参数，并返回一个数组，包含所有匹配结果。如果没有匹配到，则返回 null。
            const currentCount = parseInt(totalItemsElement.textContent.match(/\d+/)) || 0;
            //totalItemsElement.textContent = \共 ${currentCount + 1} 件商品`;`：更新总商品数量，每收到一个新产品，数量增加 1。
            totalItemsElement.textContent = `共 ${currentCount + 1} 件商品`;
        };
        
        // socket.onerror：这是一个事件处理程序，当 WebSocket 连接中发生错误时会触发。
        //function(error)：这个函数接收一个 error 对象，包含了有关错误的信息。
        socket.onerror = function(error) {
            //console.error('WebSocket Error:', error);：使用 console.error 打印错误信息到浏览器的控制台，以便开发者能够查看和调试这个错误。
            console.error('WebSocket Error:', error);
        };

        // socket.onclose：这是另一个事件处理程序，当 WebSocket 连接关闭时会触发。
        //function(event)：这个函数接收一个 event 对象，包含了关于关闭事件的详细信息。
        socket.onclose = function(event) {
            //console.log('WebSocket closed:', event);：使用 console.log 在控制台记录 WebSocket 关闭的事件信息，这样开发者就知道连接已经关闭了。
            console.log('WebSocket closed:', event);
            // alert("WebSocket连接已关闭。");：显示一个警告框，通知用户 WebSocket 连接已经关闭。这个提示对用户来说是一个明显的反馈，表明他们的连接已断开。
            alert("WebSocket连接已关闭。");
        };
    </script>
</body>
</html>
